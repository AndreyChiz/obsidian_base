Строки в Python - это неизменяемые (immutable) объекты, что означает, что после создания строки нельзя изменить ее содержимое напрямую. Если вы выполняете операции над строками (например, конкатенацию или замену), Python создает новую строку в памяти.

----
## Структура

CPython, структура объекта строки (`str`) 

```c
typedef struct {
    PyObject_VAR_HEAD
    long ob_shash;
    int ob_sstate;
    char ob_sval[1]; // Начало массива символов, содержащих данные строки
} PyStringObject;
```

Здесь:

- `PyObject_VAR_HEAD`: Заголовок объекта, включающий счетчик ссылок и указатель на тип объекта (`ob_refcnt` и `ob_type`).

- `ob_shash`: Хэш-значение строки для оптимизации операций сравнения.

- `ob_sstate`: Внутреннее состояние строки для оптимизации операций.

- `ob_sval[1]`: Это начало массива символов, который содержит фактические данные строки. Этот массив просто начинается с одного символа, но на самом деле это место, где хранятся все символы строки.


`char ob_sval[1];` с использованием `[1]` является трюком, известным как "гибкий массив" или "гибкий член массива" (flexible array member). Этот трюк позволяет создать массив переменной длины в структуре, где размер массива будет определен _**динамически при выделении памяти для объекта**_.


|Метод|Сигнатура|Описание метода|Описание параметров|Временная сложность / Сложность по памяти|
|---|---|---|---|---|
|capitalize()|`str.capitalize()`|Переводит первый символ строки в верхний регистр, а остальные в нижний.|Нет|O(N) / O(N)|
|casefold()|`str.casefold()`|Возвращает копию строки в нижнем регистре с учетом локали.|Нет|O(N) / O(N)|
|center(width, fillchar)|`str.center(width, fillchar)`|Возвращает строку, выровненную по центру и заполненную символами `fillchar`.|`width`: Ширина, `fillchar`: Заполнитель|O(N) / O(N)|
|count(sub, start, end)|`str.count(sub, start, end)`|Возвращает количество вхождений подстроки `sub` в строку.|`sub`: Подстрока, `start`: Начальный индекс, `end`: Конечный индекс|O(N * M) / O(1)|
|encode(encoding, errors)|`str.encode(encoding, errors)`|Возвращает закодированное представление строки.|`encoding`: Кодировка, `errors`: Обработка ошибок|O(N) / O(N)|
|endswith(suffix, start, end)|`str.endswith(suffix, start, end)`|Проверяет, заканчивается ли строка указанным суффиксом.|`suffix`: Суффикс, `start`: Начальный индекс, `end`: Конечный индекс|O(M) / O(1)|
|expandtabs(tabsize)|`str.expandtabs(tabsize)`|Заменяет символы табуляции на пробелы, используя ширину `tabsize`.|`tabsize`: Размер табуляции|O(N) / O(N)|
|find(sub, start, end)|`str.find(sub, start, end)`|Возвращает индекс первого вхождения подстроки `sub` в строку или -1.|`sub`: Подстрока, `start`: Начальный индекс, `end`: Конечный индекс|O(N * M) / O(1)|
| format(args, kwargs) | `str.format(*args, **kwargs)` | Форматирует строку, подставляя аргументы в {} места в строке. | `*args`: Позиционные аргументы, `**kwargs`: Именованные аргументы | O(N) / O(N)|
| format_map(mapping) |` str.format_map(mapping)` | Форматирует строку, используя ключи из словаря в {} места в строке. |` mapping`: Словарь с ключами для форматирования |


| Метод               | Сигнатура                               | Описание метода                     | Описание параметров                  | Временная сложность / Сложность по памяти |
|---------------------|-----------------------------------------|------------------------------------|------------------------------------|----------------------------------------|
| isprintable()       | `str.isprintable()`                    | Проверяет, состоит ли строка только из печатных символов.              | Нет                                | O(N) / O(1)                            |
| isspace()           | `str.isspace()`                        | Проверяет, состоит ли строка только из пробельных символов.           | Нет                                | O(N) / O(1)                            |
| istitle()           | `str.istitle()`                        | Проверяет, начинается ли каждое слово в строке с заглавной буквы.    | Нет                                | O(N) / O(1)                            |
| isupper()           | `str.isupper()`                        | Проверяет, состоит ли строка только из символов в верхнем регистре.   | Нет                                | O(N) / O(1)                            |
| join(iterable)      | `str.join(iterable)`                   | Соединяет строки из итерируемого объекта с помощью текущей строки в качестве разделителя. | `iterable`: Итерируемый объект | O(N * M) / O(N)                       |
| ljust(width, fillchar) | `str.ljust(width, fillchar)`         | Возвращает строку, выровненную по левому краю и заполненную символами `fillchar`. | `width`: Ширина, `fillchar`: Заполнитель | O(N) / O(N)                            |
| lower()             | `str.lower()`                          | Возвращает копию строки, приведенную к нижнему регистру.              | Нет                                | O(N) / O(N)                            |
| lstrip(chars)       | `str.lstrip(chars)`                    | Возвращает копию строки с удаленными символами слева, указанными в `chars`. | `chars`: Строка символов для удаления | O(N) / O(N)                            |
| partition(sep)     | `str.partition(sep)`                   | Разделяет строку на три части: до первого вхождения `sep`, сам `sep` и всё после. | `sep`: Разделитель | O(N) / O(N)                            |
| replace(old, new, count) | `str.replace(old, new, count)` | Возвращает копию строки с заменой всех вхождений `old` на `new` не более чем `count` раз. | `old`: Заменяемая подстрока, `new`: Подстрока-замена, `count`: Максимальное количество замен | O(N * M) / O(N)                       |

|Сигнатура|Описание метода|Описание параметров|Временная сложность / Сложность по памяти|
|---|---|---|---|
|index(sub, start, end)|`str.index(sub, start, end)`|Возвращает индекс первого вхождения подстроки `sub` в строку или вызывает ValueError.|`sub`: Подстрока, `start`: Начальный индекс, `end`: Конечный индекс|O(N * M) / O(1)|
|isalnum()|`str.isalnum()`|Проверяет, состоит ли строка только из буквенно-цифровых символов.|Нет|O(N) / O(1)|
|isalpha()|`str.isalpha()`|Проверяет, состоит ли строка только из буквенных символов.|Нет|O(N) / O(1)|
|isascii()|`str.isascii()`|Проверяет, состоит ли строка только из символов ASCII.|Нет|O(N) / O(1)|
|isdecimal()|`str.isdecimal()`|Проверяет, состоит ли строка только из десятичных цифр.|Нет|O(N) / O(1)|
|isdigit()|`str.isdigit()`|Проверяет, состоит ли строка только из цифр.|Нет|O(N) / O(1)|
|isidentifier()|`str.isidentifier()`|Проверяет, является ли строка корректным идентификатором Python.|Нет|O(N) / O(1)|
|islower()|`str.islower()`|Проверяет, состоит ли строка только из символов в нижнем регистре.|Нет|O(N) / O(1)|
|isnumeric()|`str.isnumeric()`|Проверяет, состоит ли строка только из числовых символов.|Нет||

| Метод               | Сигнатура                               | Описание метода                     | Описание параметров                  | Временная сложность / Сложность по памяти |
|---------------------|-----------------------------------------|------------------------------------|------------------------------------|----------------------------------------|
| rfind(sub, start, end) | `str.rfind(sub, start, end)`       | Возвращает индекс последнего вхождения подстроки `sub` в строку или -1.     | `sub`: Подстрока, `start`: Начальный индекс, `end`: Конечный индекс | O(N * M) / O(1)                       |
| rindex(sub, start, end) | `str.rindex(sub, start, end)`   | Возвращает индекс последнего вхождения подстроки `sub` в строку или вызывает ValueError. | `sub`: Подстрока, `start`: Начальный индекс, `end`: Конечный индекс | O(N * M) / O(1)                       |
| rjust(width, fillchar) | `str.rjust(width, fillchar)`       | Возвращает строку, выровненную по правому краю и заполненную символами `fillchar`. | `width`: Ширина, `fillchar`: Заполнитель | O(N) / O(N)                            |
| rpartition(sep)     | `str.rpartition(sep)`                 | Разделяет строку на три части: до последнего вхождения `sep`, сам `sep` и всё после. | `sep`: Разделитель | O(N) / O(N)                            |
| rsplit(sep, maxsplit) | `str.rsplit(sep, maxsplit)`       | Разделяет строку на подстроки справа налево, используя разделитель `sep`. | `sep`: Разделитель, `maxsplit`: Максимальное количество разделений | O(N) / O(N)                            |
| rstrip(chars)       | `str.rstrip(chars)`                    | Возвращает копию строки с удаленными символами справа, указанными в `chars`. | `chars`: Строка символов для удаления | O(N) / O(N)                            |
| split(sep, maxsplit) | `str.split(sep, maxsplit)`         | Разделяет строку на подстроки, используя разделитель `sep`.             | `sep`: Разделитель, `maxsplit`: Максимальное количество разделений | O(N) / O(N)                            |
| splitlines(keepends) | `str.splitlines(keepends)`         | Разделяет строку на строки по символам новой строки.                  | `keepends`: Флаг сохранения символов новой строки | O(N) / O(N)                            |
| startswith(prefix, start, end) | `str.startswith(prefix, start, end)` | Проверяет, начинается ли строка указанным префиксом.                  | `prefix`: Префикс, `start`: Начальный индекс, `end`: Конечный индекс | O(M) / O(1)                            |



| Метод               | Сигнатура                               | Описание метода                     | Описание параметров                  | Временная сложность / Сложность по памяти |
|---------------------|-----------------------------------------|------------------------------------|------------------------------------|----------------------------------------|
| strip(chars)       | `str.strip(chars)`                    | Возвращает копию строки с удаленными символами слева и справа, указанными в `chars`. | `chars`: Строка символов для удаления | O(N) / O(N)                            |
| swapcase()          | `str.swapcase()`                       | Возвращает строку с обмененными регистрами букв.                     | Нет                                | O(N) / O(N)                            |
| title()             | `str.title()`                          | Возвращает строку, где каждое слово начинается с заглавной буквы.    | Нет                                | O(N) / O(N)                            |
| upper()             | `str.upper()`                          | Возвращает копию строки, приведенную к верхнему регистру.           | Нет                                | O(N) / O(N)                            |
| zfill(width)       | `str.zfill(width)`                     | Дополняет строку слева нулями до указанной ширины.                  | `width`: Ширина заполнения          | O(N) / O(N)                            |
| encode(encoding, errors) | `str.encode(encoding, errors)`   | Возвращает закодированное представление строки.                  | `encoding`: Кодировка, `errors`: Обработка ошибок | O(N) / O(N)                            |

----
## Everyday string


1. **Форматирование строк**:
```python
name = "Alice"
age = 30
message = "Привет, меня зовут {} и мне {} лет.".format(name, age)
print(message)  # Вывод: Привет, меня зовут Alice и мне 30 лет.
```

2. **Разделение и объединение строк**:
```python
text = "apple,orange,banana"
fruits_list = text.split(',')
print(fruits_list)  # Вывод: ['apple', 'orange', 'banana']

fruits_string = "-".join(fruits_list)
print(fruits_string)  # Вывод: apple-orange-banana
```

3. **Поиск и замена подстрок**:
```python
sentence = "Python is fun!"
if "fun" in sentence:
    print("Есть слово 'fun' в предложении.")

new_sentence = sentence.replace("fun", "exciting")
print(new_sentence)  # Вывод: Python is exciting!
```

4. **Удаление лишних символов**:
```python
text = "   Пробелы по обоим концам   "
cleaned_text = text.strip()
print(cleaned_text)  # Вывод: Пробелы по обоим концам
```

5. **Преобразование регистра**:
```python
message = "Привет, Мир!"
print(message.lower())  # Вывод: привет, мир!
print(message.upper())  # Вывод: ПРИВЕТ, МИР!
```

6. **Проверка типа символов**:
```python
word = "Hello123"
print(word.isalpha())  # Вывод: False (содержит цифры)
print(word.isdigit())  # Вывод: False (содержит буквы)
print(word.isalnum())  # Вывод: True (содержит буквы и цифры)
```

7. **Извлечение подстрок**:
```python
text = "Python Programming"
print(text[0])         # Вывод: P
print(text[7:18])      # Вывод: Programming
print(text[-11:])      # Вывод: Programming
```

8. **Поиск и сравнение**:
```python
sentence = "Python is great!"
if sentence.startswith("Python"):
    print("Строка начинается с 'Python'.")
if "great" in sentence:
    print("Строка содержит 'great'.")
```

9. **Форматирование вывода**:
```python
import datetime
current_date = datetime.datetime.now()
formatted_date = current_date.strftime("%Y-%m-%d %H:%M:%S")
print("Текущая дата и время:", formatted_date)
```

10. **Регулярные выражения**:
```python
import re
text = "Hello, my email is abc@example.com"
pattern = r'\b\w+@\w+\.\w+\b'
emails = re.findall(pattern, text)
print(emails)  # Вывод: ['abc@example.com']
```

Это лишь несколько примеров. В Python существует множество возможностей для работы со строками, и выбор методов зависит от конкретных задач.