https://habitica.fandom.com/ru/wiki/%D0%A8%D0%BF%D0%B0%D1%80%D0%B3%D0%B0%D0%BB%D0%BA%D0%B0_%D0%BF%D0%BE_Markdown


приведи таблицу методов для str колонки : 'сигнатура' | 'описание метода' | 'описание каждого возможного параметра метода' | 'временная сложность /сложность по памяти' таблицу раздели на несколько сообщение по 10 строк. прерд выводом очередной таблицы спрашивай

Конечно, вот следующие 10 строк таблицы методов для объекта строки (`str`):

| Метод               | Сигнатура                               | Описание метода                     | Описание параметров                  | Временная сложность / Сложность по памяти |
|---------------------|-----------------------------------------|------------------------------------|------------------------------------|----------------------------------------|
| isprintable()       | `str.isprintable()`                    | Проверяет, состоит ли строка только из печатных символов.              | Нет                                | O(N) / O(1)                            |
| isspace()           | `str.isspace()`                        | Проверяет, состоит ли строка только из пробельных символов.           | Нет                                | O(N) / O(1)                            |
| istitle()           | `str.istitle()`                        | Проверяет, начинается ли каждое слово в строке с заглавной буквы.    | Нет                                | O(N) / O(1)                            |
| isupper()           | `str.isupper()`                        | Проверяет, состоит ли строка только из символов в верхнем регистре.   | Нет                                | O(N) / O(1)                            |
| join(iterable)      | `str.join(iterable)`                   | Соединяет строки из итерируемого объекта с помощью текущей строки в качестве разделителя. | `iterable`: Итерируемый объект | O(N * M) / O(N)                       |
| ljust(width, fillchar) | `str.ljust(width, fillchar)`         | Возвращает строку, выровненную по левому краю и заполненную символами `fillchar`. | `width`: Ширина, `fillchar`: Заполнитель | O(N) / O(N)                            |
| lower()             | `str.lower()`                          | Возвращает копию строки, приведенную к нижнему регистру.              | Нет                                | O(N) / O(N)                            |
| lstrip(chars)       | `str.lstrip(chars)`                    | Возвращает копию строки с удаленными символами слева, указанными в `chars`. | `chars`: Строка символов для удаления | O(N) / O(N)                            |
| partition(sep)     | `str.partition(sep)`                   | Разделяет строку на три части: до первого вхождения `sep`, сам `sep` и всё после. | `sep`: Разделитель | O(N) / O(N)                            |
| replace(old, new, count) | `str.replace(old, new, count)` | Возвращает копию строки с заменой всех вхождений `old` на `new` не более чем `count` раз. | `old`: Заменяемая подстрока, `new`: Подстрока-замена, `count`: Максимальное количество замен | O(N * M) / O(N)                       |



| Метод               | Сигнатура                               | Описание метода                     | Описание параметров                  | Временная сложность / Сложность по памяти |
|---------------------|-----------------------------------------|------------------------------------|------------------------------------|----------------------------------------|
| rfind(sub, start, end) | `str.rfind(sub, start, end)`       | Возвращает индекс последнего вхождения подстроки `sub` в строку или -1.     | `sub`: Подстрока, `start`: Начальный индекс, `end`: Конечный индекс | O(N * M) / O(1)                       |
| rindex(sub, start, end) | `str.rindex(sub, start, end)`   | Возвращает индекс последнего вхождения подстроки `sub` в строку или вызывает ValueError. | `sub`: Подстрока, `start`: Начальный индекс, `end`: Конечный индекс | O(N * M) / O(1)                       |
| rjust(width, fillchar) | `str.rjust(width, fillchar)`       | Возвращает строку, выровненную по правому краю и заполненную символами `fillchar`. | `width`: Ширина, `fillchar`: Заполнитель | O(N) / O(N)                            |
| rpartition(sep)     | `str.rpartition(sep)`                 | Разделяет строку на три части: до последнего вхождения `sep`, сам `sep` и всё после. | `sep`: Разделитель | O(N) / O(N)                            |
| rsplit(sep, maxsplit) | `str.rsplit(sep, maxsplit)`       | Разделяет строку на подстроки справа налево, используя разделитель `sep`. | `sep`: Разделитель, `maxsplit`: Максимальное количество разделений | O(N) / O(N)                            |
| rstrip(chars)       | `str.rstrip(chars)`                    | Возвращает копию строки с удаленными символами справа, указанными в `chars`. | `chars`: Строка символов для удаления | O(N) / O(N)                            |
| split(sep, maxsplit) | `str.split(sep, maxsplit)`         | Разделяет строку на подстроки, используя разделитель `sep`.             | `sep`: Разделитель, `maxsplit`: Максимальное количество разделений | O(N) / O(N)                            |
| splitlines(keepends) | `str.splitlines(keepends)`         | Разделяет строку на строки по символам новой строки.                  | `keepends`: Флаг сохранения символов новой строки | O(N) / O(N)                            |
| startswith(prefix, start, end) | `str.startswith(prefix, start, end)` | Проверяет, начинается ли строка указанным префиксом.                  | `prefix`: Префикс, `start`: Начальный индекс, `end`: Конечный индекс | O(M) / O(1)                            |



| Метод               | Сигнатура                               | Описание метода                     | Описание параметров                  | Временная сложность / Сложность по памяти |
|---------------------|-----------------------------------------|------------------------------------|------------------------------------|----------------------------------------|
| strip(chars)       | `str.strip(chars)`                    | Возвращает копию строки с удаленными символами слева и справа, указанными в `chars`. | `chars`: Строка символов для удаления | O(N) / O(N)                            |
| swapcase()          | `str.swapcase()`                       | Возвращает строку с обмененными регистрами букв.                     | Нет                                | O(N) / O(N)                            |
| title()             | `str.title()`                          | Возвращает строку, где каждое слово начинается с заглавной буквы.    | Нет                                | O(N) / O(N)                            |
| upper()             | `str.upper()`                          | Возвращает копию строки, приведенную к верхнему регистру.           | Нет                                | O(N) / O(N)                            |
| zfill(width)       | `str.zfill(width)`                     | Дополняет строку слева нулями до указанной ширины.                  | `width`: Ширина заполнения          | O(N) / O(N)                            |
| encode(encoding, errors) | `str.encode(encoding, errors)`   | Возвращает закодированное представление строки.                  | `encoding`: Кодировка, `errors`: Обработка ошибок | O(N) / O(N)                            |

----
## Everyday string


1. **Форматирование строк**:
```python
name = "Alice"
age = 30
message = "Привет, меня зовут {} и мне {} лет.".format(name, age)
print(message)  # Вывод: Привет, меня зовут Alice и мне 30 лет.
```

2. **Разделение и объединение строк**:
```python
text = "apple,orange,banana"
fruits_list = text.split(',')
print(fruits_list)  # Вывод: ['apple', 'orange', 'banana']

fruits_string = "-".join(fruits_list)
print(fruits_string)  # Вывод: apple-orange-banana
```

3. **Поиск и замена подстрок**:
```python
sentence = "Python is fun!"
if "fun" in sentence:
    print("Есть слово 'fun' в предложении.")

new_sentence = sentence.replace("fun", "exciting")
print(new_sentence)  # Вывод: Python is exciting!
```

4. **Удаление лишних символов**:
```python
text = "   Пробелы по обоим концам   "
cleaned_text = text.strip()
print(cleaned_text)  # Вывод: Пробелы по обоим концам
```

5. **Преобразование регистра**:
```python
message = "Привет, Мир!"
print(message.lower())  # Вывод: привет, мир!
print(message.upper())  # Вывод: ПРИВЕТ, МИР!
```

6. **Проверка типа символов**:
```python
word = "Hello123"
print(word.isalpha())  # Вывод: False (содержит цифры)
print(word.isdigit())  # Вывод: False (содержит буквы)
print(word.isalnum())  # Вывод: True (содержит буквы и цифры)
```

7. **Извлечение подстрок**:
```python
text = "Python Programming"
print(text[0])         # Вывод: P
print(text[7:18])      # Вывод: Programming
print(text[-11:])      # Вывод: Programming
```

8. **Поиск и сравнение**:
```python
sentence = "Python is great!"
if sentence.startswith("Python"):
    print("Строка начинается с 'Python'.")
if "great" in sentence:
    print("Строка содержит 'great'.")
```

9. **Форматирование вывода**:
```python
import datetime
current_date = datetime.datetime.now()
formatted_date = current_date.strftime("%Y-%m-%d %H:%M:%S")
print("Текущая дата и время:", formatted_date)
```

10. **Регулярные выражения**:
```python
import re
text = "Hello, my email is abc@example.com"
pattern = r'\b\w+@\w+\.\w+\b'
emails = re.findall(pattern, text)
print(emails)  # Вывод: ['abc@example.com']
```

Это лишь несколько примеров. В Python существует множество возможностей для работы со строками, и выбор методов зависит от конкретных задач.