

1. **Singleton (Одиночка):** Гарантирует, что у класса есть только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.
    
2. **Strategy (Стратегия):** Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми. Позволяет изменять алгоритмы независимо от клиентов, использующих их.
    
3. **Builder (Строитель):** Позволяет создавать сложные объекты шаг за шагом. Разделяет конструирование сложного объекта от его представления.
    
4. **Prototype (Прототип):** Создает новые объекты, копируя существующие объекты, без привязки к их конкретным классам.
    
5. **Adapter (Адаптер):** Преобразует интерфейс одного класса в интерфейс другого класса так, чтобы они могли работать вместе.
    
6. **Composite (Компоновщик):** Структурирует объекты в древовидные структуры для представления частично-целостных иерархий.
    
7. **Proxy (Заместитель):** Предоставляет замену другого объекта для контроля доступа к нему или для добавления дополнительной функциональности.
    
8. **Command (Команда):** Инкапсулирует запрос в виде объекта, делая возможным параметризацию клиентов с различными запросами, организацию очереди запросов и поддержку отмены операций.
    
9. **Iterator (Итератор):** Предоставляет способ последовательно обходить элементы составного объекта, не раскрывая его внутреннего представления.
    
10. **Observer (Наблюдатель):** Определяет зависимость один ко многим между объектами так, что при изменении состояния одного объекта все его зависимости уведомляются и обновляются автоматически.
    
11. **Chain of Responsibility (Цепочка обязанностей):** Позволяет передавать запросы последовательно по цепочке обработчиков, избегая привязки отправителя запроса к его получателю.
    
12. **Visitor (Посетитель):** Позволяет определить новую операцию без изменения классов объектов, к которым эта операция применяется.
    
13. **Decorator (Декоратор):** Динамически добавляет объекту новые обязанности, предоставляя гибкую альтернативу наследованию для расширения функциональности.
    
14. **Command (Команда):** Инкапсулирует запрос в виде объекта, делая возможным параметризацию клиентов с различными запросами, организацию очереди запросов и поддержку отмены операций.
    
15. **State (Состояние):** Позволяет объекту изменять свое поведение при изменении своего состояния.


|Паттерн|Когда использовать|
|---|---|
|**Фабричный метод**|- Когда у вас есть семейство связанных продуктов.|
||- Когда вы хотите предоставить пользователю возможность расширять, не изменяя базовый код.|
||- Когда создание объектов предоставляет больше гибкости, чем использование конструктора.|
|**Абстрактная фабрика**|- Когда у вас есть семейство взаимосвязанных продуктов.|
||- Когда вы хотите обеспечить непротиворечивость создаваемых объектов.|
||- Когда вы хотите предоставить интерфейс для создания семейств объектов, но оставить подробности реализации подклассам.|
|**Состояние**|- Когда поведение объекта зависит от его состояния и может изменяться во времени.|
||- Когда у вас есть большой, конечный набор состояний и переходов между ними.|
||- Когда вы хотите избежать использования многочисленных вложенных условий.|
|**Наблюдатель**|- Когда один объект изменяет свое состояние, и другие объекты должны быть уведомлены об этом изменении.|
||- Когда вы хотите реализовать слабую связанность между объектами.|
||- Когда у вас есть один издатель и несколько подписчиков, и они не должны знать друг о друге.|
|**Декоратор**|- Когда вы хотите добавлять новую функциональность объекту динамически и прозрачно.|
||- Когда вы хотите избежать использования наследования для расширения функциональности.|
||- Когда у вас есть несколько вариантов декорирования объекта и их можно комбинировать.|

